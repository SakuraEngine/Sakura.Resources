# ECS in Sakura

## Introduce

游戏是对性能非常敏感的，不管是 AAA 游戏的内容量还是手机游戏的耗电量发热量都对性能有严苛的指标，所以游戏开发需要针对性能做很多工作，ECS 的主要作用就是减少这些工作，在 CPU 的频率一般不会成为瓶颈的现状下，ECS 主要从缓存和多线程入手（非算法层面），对硬件的性能进行暴力释放。

Sakura 中实现了自己的 ECS 模块 **Dual**，**Dual** 有如下特性：

* C ABI，高移植性
* 完全擦除的类型系统，1s 极速编译
* 精简的代码，一共 4k loc
* 极简的 API，无任何过度封装
* 框架性能消耗几乎为 0
* 大量的基本特性支持

> 当前 **Dual** 处于早期阶段，请勿用于生产

## 对象模型

> 这个部分有大量的资料讲过了，简单带过，读者可以跳过

增加缓存性能的方案主要从两个方向出发：数据的连续性，访问的连续性。意思是，数据应该连续摆放（数组而不是链表），访问该线性访问（`arr[i][j]`而不是`arr[j][i]`）。

从这种指导思想出发，我们做了一些工作：

1. 把对象按访问的代码不同拆解成了 N 个组件，代码只访问需要访问的组件。
2. 把相同类型的组件存放在连续的数组中，代码连续的访问这个数组。
3. （可选的）将相同类型的对象放在连续的数组中。

在这些工作下，有一些有趣的性质：

* 对象成为了一个 id，使用这个 id 我们可以随机访问其拥有的组件
* （一般来说）同个类型的组件对象只能拥有一个
* **如果两份代码访问不同的组件，则两份代码可以并行**

而基于是否进行第三个工作拆分出两个方案：

1. 稀疏表方案
2. 组块方案

### 稀疏表

对应的伪代码如下：

```c++
struct entities
{
    sparse_map<component1_t> component1; //同一种类型的组件放置到一起
    sparse_map<component2_t> component2;
    slot_allocator;
};
```

访问组件的代码则如下：

```SQL
select A, B from join(sparse_map<A>, sparse_map<B>);
```

访问组件时一般会选取一个稀疏表作为主表（A），在此主表中，内存访问完全连续，而其余的附表（B）则可能带有缓存浪费。

### 组块

对应的伪代码如下：

```c++
struct entities
{
    struct archetypes1 
    {
        array<component1_t> component1;
    };
    struct archetypes2 
    {
        array<component2_t> component2;
    };
     struct archetypes3 
    {
        array<component1_t> component2;
        array<component2_t> component2;
    };
    array<archetypes>;
    indirect_array; //随机访问
    slot_allocator;
}
```

访问组件的代码则如下：

```SQL
select A,B from archetype where archetype.match(A, B);
```

如同上述说到，这种方案将相同类型的对象也放到了连续的数组中（archetype），这使得内存的访问完全连续，这也使得 SIMD 有更大的发挥空间，作为代价，在对象类型变动的时候，需要移动整个对象到新的组中。**有趣的是，稀疏表方案也可以部分采用这种做法**：维护一个表组（A，B），使得 A，B 中的前 N 个对象始终同时拥有 A，B 组件，则遍历（A，B）组的时候能做到完全的内存连续，这也带来了更大的代价：搬移对象需要插入到表中间（N 之前），并且这种方案还有限制：一个表只能在一个表组中。

### 对比与选择

下面是两种选择的各方面的大概对比。

| **需求\\构架** | **SparseArray** | **Archetype**    |
| -------------- | --------------- | ---------------- |
| 数据结构       | SoA             | AoSoA            |
| 无GC           | √               | √                |
| 查询效率       | A               | A                |
| SIMD           | B               | S，连续数据      |
| 缓存命中率     | A，线性访问     | S，线性访问+数据 |
| 简洁性         | B               | B                |
| 创建性能       | S               | S                |
| 增删性能       | S               | B                |
| 随机访问       | S               | A                |
| 内存节省       | A               | A                |
| 可排序         | √               | ×                |
| 动态类型       | √               | √                |
| 多线程友好     | S               | S                |
| 序列化效率     | A               | S                |

可以看到两种方案没有绝对的优劣，在 **Dual**中，我们使用了组块方案作为 ECS 的对象模型。

## API 设计

Dual 拥有独特的 API 设计思路：

* 面向数据：在 **Dual** 中，我们遵循了面向数据的原则，弱化了对象的存在，而增强了数据的存在。具体来说，几乎所有 API 操作的目标都不是对象，而是数据：在 **Dual** 中数据被定义为 `dual_chunk_view_t`（也就是 Archetype 的一个切片），遍历时通过 `dual_chunk_view_t` 遍历，处理 entity 时通过 `dual_chunk_view_t` 进行操作，生成 entity 时直接返回 `dual_chunk_view_t` 等等。
* 批量化：在面向数据设计的基础上，**Dual** 尽量进行了批量化处理，比如在处理 entity 列表时，会先尝试将其合批为 `dual_chunk_view_t` 再进行具体的操作，在操作类型的时候（增删组件），尽量只进行一步操作：`Add(A,B)`　而不是 `Add(A), Add(B)`
* DSL: 在 Query 的创建上提供了一个极简的 DSL 用于简化代码。

## 特性

在此对象模型的基础上，**Dual** 还实现了大量的基础特性。

### Query & Overload

#### 原理

Query 作用如下：

1. 缓存查询到的组，避免反复查询（基于查询变动的次数远小于查询的次数这个假设）
2. 记录代码访问的组件，为并行做准备
3. 实现查询的重载，增加扩展性

前两个不再详细解释，重点解释重载：重载的原理为消除代码访问重叠的部分，数据不断经过代码修改形成数据流，比如一个组件 A 和过程 s1，s2，可以拥有如下两种数据流：

1. `A -> s1 -> A' -> s2 -> A''`
2. `A -> s1, s2 -> A'`

对于第二种数据流，两个过程同时修改统一数据，产生了冲突，则会触发重载决议，将 A 拆分为两个部分，分别由 s1 和 s2 处理。重载的规则为：

* 如果查询之间存在包含关系，则选择子集
* 如果查询直接存在交叉关系，则消除交叉部分

举例来说，如果 s1 的查询为 q(a,b)，s2 的查询为 q(a,b,c), s3 的查询为 q(a,b,d) 且他们触发了重载决议，则有如下行为：

* g(a, b, e) 匹配到 s1，因为 s2 和 s3 都没匹配上
* g(a, b, c, e) 匹配到 s2，此时 s1 和 s2 都匹配上了，但根据重载规则1，s2 是 s1 的子集，则取子集
* g(a, b, c, d) 不会匹配到任何一个，此时 s1 和 s3 都匹配上了，但两个存在交叉关系，此组被消除

**算法细节：** 首先取的所有查询的超集 `let super = merge(query1...n.include)` 然后把所有查询从超集中独立出来 `let queryn.exclude = substract(super, queryn.include)` 如此便有了以上的行为。

#### DSL

**Dual** 为 Query 的创建提供了一个声明式的 DSL：

* [in/out/inout/atomic/has]，表示代码的访问方式
  * in 表示只读
  * out 表示只写
  * inout 表示读写
  * atomic 表示原子写
  * has 表示不读写，只参与筛选
* [rand/seq]，表示代码访问的顺序
* ? - optional，表示可选
* $ - shared，表示只筛选共享的组件
* | - any，表示任选其一
* ! - none，表示不匹配此组件
* ' - stage，特别标记组件，拥有相同标记 Query 参与重载决议

下面是几个例子： `[inout]|A[inout]|B', [in]?C, [in]$D, [inout][rand]E, [has]!F`

### LifeTime

ECS 中的对象作为对象，也是需要生命周期管理的，**Dual** 提供了两种方案来管理生命周期：

#### Tag & Pin

原滋原味的 ECS 方案：

* 对于销毁：使用一个 Tag 来标记对象需要被销毁，然后经过用户代码处理之后再真实的销毁以及回收。框架内置了这个功能，可以标记组件需要清理，在销毁时会自动保留所有需要清理的组件并添加 DeadTag，等对象只剩下一个 DeadTag 组件的时候，对象会被回收。
* 对于拷贝：可以标记组件在拷贝的时候不被拷贝，则寻找没有这个组件的对象就能进行拷贝后处理。

这两个标记当前是一体的，叫做 Pinned Component。

#### Callback

暴力方案，每个组件类型可以注册对应的生命周期回调，框架会在合适的时机调用这些回调。包括创建、移动、拷贝、销毁等。

### Reference

**Dual** 提供了对象间引用的自动管理，用户只需要在注册组件时标记引用。则 **Dual** 会自动在

* 合并 ECS World 时保证引用不变
* 实例化一组对象时保证相对引用不变（1 -> 2 实例化为 3 -> 4 而不是 3 -> 2)

### Array

**Dual** 提供了内置的数组组件支持，数组组件和普通组件一样分配在 Archetype 中，当此组件的大小超过 Archetype 中预分配的大小之后，便会扩容到堆上。

数组组件也拥有引用自动管理的能力。

### MultiWorld

**Dual** 支持多元世界，用户可以创建多个世界同时运行。**Dual** 还支持合并世界，一个惯用法是：在读取地图区块的时候，将区块读取为一个单独的世界，然后在这个世界中执行必要的初始化操作（完全并行的），并且在初始化完成之后合并到主世界，得益于 **Dual** 选择的对象模型，这个合并的消耗几乎为 0，但是过度使用有可能产生内存碎片，为此 **Dual** 还实现了内存整理功能，在内存随便过高时可以使用碎片整理来清理碎片。

```c++
world mainWorld;
world streamWorld;
archive file("chunk1");
auto job = dispatch([&]{ streamWorld.deserialize(&file); Initialize(streamWorld); });
loop
{
    //other work
    if(job.done())
        mainWorld.merge(std::move(streamWorld));
}
```

### (De)Serialize

**Dual** 提供了内置的二进制（反）序列化功能。能序列化一组 Entity 或者直接快照整个 World，同时保证相对引用不失效。经过测试，**Dual** 能在模拟数量为 12W 的鱼群同时每帧快照并保持 60 fps。

### GUID

**Dual** 提供了内置的 GUID 组件，作为 Entity 的可持续化 ID（比如通过网络发送）。此组件保证了 Entity 在被复制时会创建新的 GUID 而不是直接拷贝。

### Mask

Mask 是 **Dual** 对查询算法的扩展，ECS 可以通过增删控件来控制对象的行为，然后在 **Dual** 的内存模型下，高频率的增删组件会带来极大的性能损耗，Mask 组件可以在不删除组件的前提下使对象的一些组件不会被匹配到，以缓存为代价平衡增删组件的代价。

### Timestamp

Timestamp 是 **Dual** 对查询算法的扩展，**Dual** 记录了每个 Archetype 最后一次被代码操作的时间戳，利用这个时间戳，用户可以跳过没有变动的数据的更新。比如变换矩阵，如果对象的位移旋转缩放都没有修改过，则不需要重新计算变换矩阵。

### MetaEntity

MetaEntity 是 **Dual** 对分组的扩展，在使用组件分组之上增加了使用元对象进行分组的能力，使得用户可以手动对对象进行额外的分组。

举例来说：将不同场景区块中的对象分到不同的组中（区块无法由预定义的类型来表达），由此对一个区块中的对象整体处理（比如极速卸载）。

于此同时，**Dual** 还在 MetaEntity 之上开放出了共享组件的能力 - 组中的对象会共享组的元对象的组件，以上面的例子来讲，可以轻松拿取到对象共享的 SceneSectionComponent 从而得知对象属于哪个区块。

