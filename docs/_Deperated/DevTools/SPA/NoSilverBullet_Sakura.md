<h1 align="center">没有银弹 & SakuraEngine</h1>
<div align="center">
人月神话读后感 & 跨平台现代游戏引擎项目构建扼要
</div>

## 综述
&emsp;&emsp;时值软工开课, 我的个人项目也正在架构构建阶段。为了完成作业, 这两周终于抽空捧起经典著作《人月神话》读了读。此书我早已入手, 奈何当初积累不足, 草草作读后觉得有如哲学圣论, 便搁置一旁了。

&emsp;&emsp;时隔一年半, 在有了相对量的软件开发经验积累后, 再度翻开此书, 终于豁然明朗。那么谨写此篇文章, 既是为了提交作业, 也是为了重构后的Sakura作序。本文也将会收录到[Sakura的文档页](https://saeruhikari.github.io/SakuraEngine/#/DevTools/SPA/NoSilverBullet_Sakura.md)中。

**后注: 最好阅览html或在线文档, 因为markdown导出pdf后图片被压缩, 排版也不令人满意。**

&emsp;&emsp;那么为了让亲爱的老师和读者建立一个上下文, 下面简单介绍下我的引擎项目:

&emsp;&emsp;作为游戏开发者, 用遍各种开闭源商业引擎后终觉手软, 一直想动手构建一个自己的引擎项目。其实代号Sakura的引擎项目, 已经是第二次开工动土了, [之前的项目](https://zhuanlan.zhihu.com/p/101331706)因为过度膨胀而胎死腹中, 做完渲染模块, 代码量扩展到3w行左右就放弃开发了。疫情封锁下, 我终于有充足的时间精力投身到SakuraEngine的重建中。

&emsp;&emsp;到目前为止, 整个系统进度良好。对我个人而言, 系统处于一个超级内聚的状态, 复杂度维持得也非常令人满意。那么下面就写上我对《人月神话》的读后感, 同时附上我在项目中所付出的实践。

## 摆脱焦油坑: 抛弃粗放模式, 为创造性提供沃土
&emsp;&emsp;作为《人月神话》的第一章, 本章抛出了一个贯穿全书的永恒问题: 软件开发/编程产品在项目后期会难以避免的陷入焦油坑困境中。

&emsp;&emsp;究其原因, 其一是项目功能的复杂性和编码的复杂性呈指数映射关系。第二点较为隐晦的点在于, 越是追求系统化和通用化, 就要在编程中付出越大的复杂性代价。下图中的"九倍演进"即是在描述这个过程。
<h1 align="center">

![系统性&通用性的代价](https://file.moetu.org/images/2020/03/13/J45FQ8EHVSCCO60M195d62c6891a317f2.png)
</h1>

&emsp;&emsp;系统化, 意味着接口必须保持一致性和全局唯一性。设计过度的接口会造成系统使用者的混乱, 更会造成系统复杂度熵的提升。设计不当的接口会使系统用户与系统内部的界面不足, 进而引入更多的开洞行为, 因而维持系统的良好接口需要很大的代价。

&emsp;&emsp;通用化, 是作为商业产品的需求。一旦程序需要处理通用化问题, 就要面对大量的状况分支, 并在边际问题上付出巨大的开发&调试&维护成本。提供文档同样是通用产品的麻烦所在。好的文档必须足够简明扼要, 又要描述问题的全部方面。做出一个操作, 会带来如何的作用以及副作用, 将这些信息确实转达给用户是非常困难的。

&emsp;&emsp;非常不幸的是, 我们的目标产品Sakura作为一个游戏引擎完美兼备了以上的所有复杂点。一个游戏引擎必须是一个编程系统, 否则会对下层的API Caller造成巨大的困扰。同时游戏引擎也必须是一个完备的编程产品, 因为美术, 策划, 特效等不懂编程的开发人员也要投入开发中, 他们是游戏资产的生产者, 也是最直接的用户。至此, 我们用一些篇幅充分证明了目标产品Sakura的复杂性。
<h5 align="center">

![游戏引擎架构](https://file.moetu.org/images/2020/03/13/EngineFracture198d1e92f6b9c098.md.jpg)</br>游戏引擎架构
</h5>

&emsp;&emsp;比较有趣的是, 《人月神话》在提出焦油坑问题后抛出了两个子章节: 职业的乐趣&职业的苦恼。乍眼一看, 这两部分如同排版错误, 突兀的出现在焦油坑问题的下方。实际上, 这里是在为解决焦油坑问题提出方法论:

- 程序员总是乐于主动解决问题和进行设计(职业的乐趣, 现实中的程序员几乎也都是工作狂), 但是依赖等无关复杂度的引入使程序员非常苦恼(职业的苦恼);
- 因此, 构建出一个让程序员可以不受干扰, 专心解决自身问题的环境是一个有效的手段。

&emsp;&emsp;其实缓解这个问题的一个有效办法就是**提供便捷的扩展手段**, 并提供一套基本导论来使程序员自行建立起**高聚合低耦合**的功能模块。功能模块可以方便的链接到引擎中, 并提供嵌入程序循环的有效手段。

&emsp;&emsp;回到SakuraEngine的设计, 我们通过**插件/模块系统**的建立, 在项目建立之初就缓解了焦油坑问题。

## SakuraEngine中的模块化开发: 从状态地狱摆脱
&emsp;&emsp;SakuraEngine使用完全的模块化开发。
### 什么是模块化开发
&emsp;&emsp;模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。例如我们将游戏引擎绘制的业务拆分为渲染设备模块, 渲染调度模块, 场景模块以及绘制提交模块。 
### 为什么采用模块化?
&emsp;&emsp;很多应用程序在长期的开发后陷入[焦油坑](https://zh.wikipedia.org/wiki/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D#%E7%84%A6%E6%B2%B9%E5%9D%91)窘境, 难以进行进一步的扩展, 甚至无法维护。为了避免在开发后期遇到这样的问题, 需要提出一套解决方案。首先需要对应用程序开发做进一步的认知与理解。

实际上, 程序开发中的业务无外乎以下两项:
- 功能
- 状态(数据)

&emsp;&emsp;为了摘出概念, 下文中的**功能**我们指可以去模块实现的物件, 例如纯头库和静态库。在实际项目中, 有如下的规律:

|问题\难度|开发|维护|
|:--:|:--:|:--:|
|功能|难|易|
|状态|nil|难|


&emsp;&emsp;对于难以开发的功能, 我们本着复用的态度。大部分时候代码级的复用已经足够, 但是由于数据(尤其是状态)的全局唯一性, 我们做不到这种级别的粗暴复用。

&emsp;&emsp;比如说, 多次链接复用带状态的lib会致使应用程序中有多份对象副本。而代码级别的重定义则会引发Compile Error。

&emsp;&emsp;功能代码的强耦合会降低可读性, 但在实际维护上不会造成过大的困扰, 因为代码可以随意的拷贝修改, 很难造成纠缠性的难解问题。实际上在工程中, 大部分时候我们在和各种交错凌乱的状态进行斗争:
- 由于状态本身和符号强挂钩, 这使得状态一旦写下就再也难以移动;
- 状态与业务强挂钩, 这也意味着无论如何设计, 业务代码中都难以避免各种状态的复杂引用;
- 需求的复杂变化会引入更多的状态以及功能。
  - 对于功能, 我们可以弃用旧函数/接口, 重起炉灶使用新的函数/接口而不引入过多的问题。
  - 然而对于一个运行着的系统而言, 无论如何都无法无视掉一个旧的状态。无视并停止维护一个状态, 可能会使系统的旧组件无法再运行下去;
  

&emsp;&emsp;一个形象的例子是面向对象以及面向接口(这里不讨论他们的包含关系)开发, OOP的一部分问题在于**耦合了状态和功能**, 这使得使用某个对象的功能必须考虑它特有的那些状态。面向接口开发使得功能和状态**可以**解耦, 引用一个接口实际上是引用了对象的功能组。 

&emsp;&emsp;请注意上文中的**可以**, 因为对象内的接口实现同样有权修改对象的状态, 这使得不规范的接口化开发会退化至OOP。除非接口被声明为功能如此, 我们总应该在实现中引入更少的副作用。或者仅使用**静态类+函数/模板**进行**纯功能**的实现, 而非陷入对象化的泥潭。

&emsp;&emsp;模块化的核心功能就是将业务进行**子服务化**, 每个服务(模块)专一地维护它自己的那些状态, 来避免**状态地狱**的产生。同时为了维持功能的可复用性, SakuraEngine推荐将模块的功能摘出实现, 导出为静态库以重用。将静态库链接至少量维护有状态的源并导出动态装载的模块, 如此可将维护状态的业务限制在极小的一个范围中。

### 如何在SakuraEngine中实现模块化开发
&emsp;&emsp;模块化开发的一大问题是维护模块信息与模块之间的关系。有以下几点:
- 链接
- 版本控制
- 依赖
- 装载与初始化
- 自动卸载与清理

&emsp;&emsp;由于C++缺失必须的语言级功能, 并且我们需要维护模块化开发的模块依赖, SakuraEngine的模块化开发基于自定义开发工具[SPA](https://saeruhikari.github.io/SakuraEngine/#/DevTools/SPA/SakuraPackageAdminister)。SPA需要用户在编辑时提供模块元数据(名称/版本/依赖等),工具自动在编译时将元数据注入, 并在运行时做依赖保序的加载以及初始化。

&emsp;&emsp;链接部分, SPA采取不干预的制度。这也是为了确保用户可以自由链接, 在大部分时候选择并链接到自己想要的静态库, 而不是递归地去链接动态库, 引入不必要的overhead和runtime eror。

&emsp;&emsp;版本控制的部分则在编译时进行保证。批处理文件会在编译时确认json内填写的依赖以及版本, 对于版本不符的依赖直接抛出error。SakuraEngine保证第一方插件的版本与引擎大版本一致, 这样可以简化引擎内的版本控制, 避免引擎插件间的版本冲突。

&emsp;&emsp;SPA同时支持**静态模块**和**动态模块**且都可以引入状态, 但在不能确保唯一链接的情况下, 请总是使用**动态模块**。

&emsp;&emsp;更为详细的内容, 请参阅[SPA](https://saeruhikari.github.io/SakuraEngine/#/DevTools/SPA/SakuraPackageAdminister)页。您可以在SPA的文档下学会如何创建用于SakruaEngine的模块, 并且了解到SPA批处理工具的一切细节。

## 没有银弹: 时刻保持灵活

### 原罪: 困难的根源性
&emsp;&emsp;在《没有银弹》这篇经典论文中, 最经典的观点便是: 

<h4 align="center"> 软件开发总是非常困难的, 天生就没有银弹 </h4>

&emsp;&emsp;对软件的内在特性, 作者做了如下提炼:

- 复杂度: 数字计算机本身就比人类建造的大多数东西复杂。计算机拥有大量的状态，这使得构
思、描述和测试都非常困难。
- 一致性: 软件工程师必须控制的很多复杂度是随心所欲、毫无规则可言的，来自若干必须遵循的人为惯例和系统。
- 易变: 所有成功的软件都会发生变更。其中部分的原因是因为系统中的软件包含了很多功能，而功能是最容易感受变更压力的部分。
- 不可见性: 软件的客观存在不具有空间的形体特征。
  

&emsp;&emsp;作者提出这些观点已过去多年, 然而时过境迁, 作者所提出的所有观点都被恰如其分的在各种各样的项目中验证了。正如作者所言, 论文中提到的, 当时提出的那些所谓"银弹的希望", 如今都在前进的路上达到了自己的极限之处。

#### 高级编程语言
&emsp;&emsp;高级语言只能为开发带来便利, 在减少系统复杂度上收效甚微(当然反射等语言功能可以辅助程序员进行解耦设计, 但实际问题远远复杂得多)。事实上, 除了C++和C#外的高级语言几乎都是不支持多范式的, 单一范式的使用就使得它们不可能成为银弹;

#### 面向对象编程
&emsp;&emsp;OOP拥有良好的普适性, 经过几十年的演化, 一路发展出IOP(面向接口编程)等扩展范式, 现在已经完全成熟, 但仍然不能成为银弹。OOP可以抽象绝大部分的问题, 这点着实优秀。

&emsp;&emsp;然而, OOP的介入使得状态被大量引入和隐藏, 副作用管理变成了一件非常头疼的事情, 超长的派生链更给实际项目中的调试带来了困扰。一些只支持OOP范式的语言(比如java)如今已经饱为人诟病。
#### 图形化编程
&emsp;&emsp;事实证明, 图形化编程对于大部分程序员来说就是crap。虚幻引擎的[蓝图系统](https://docs.unrealengine.com/zh-CN/Engine/Blueprints/index.html)是当下最完备最通用的图形化编程系统, 它提供了非常完备的语言设施, 比如OOP, 接口, 函数库封包, FP, 反射, GC, 通信以及C++对接等。
<h4 align="center">

![蓝图](https://file.moetu.org/images/2020/03/13/2MFGI0ZE8PHMXCAa3cf55c008bfea42.md.png)
</h4>

&emsp;&emsp;在小规模项目中图形化编程非常方便, 甚至可以交给策划来制作游戏逻辑脚本。然而在实践中图形化编程反而引入了前无古人后无来者的超级复杂度。

- 图形化编程难以文本化, 几乎都是二进制保持执行单元/编译单元。这就给版本控制带来了前所未有的阻力---你无法控制一个binary的版本, 因为它不是人类可读或者逻辑可解的;
- 图形化编程的信息密度小的可怜。代码三行描述结束的东西, 在图形化编程时往往需要大排的节点串, 同时节点的分布也不能有一个文本缩进一样的统一格式, 这使得团队协作中的互阅变得尤为困难。 

&emsp;&emsp;因此目前的图形化编程几乎只用于DSL(专门领域编程语言)中, 比如Octane等渲染器的节点化图形编程器, Houdini的节点化可编程几何引擎以及SubstanceDesigner的图像引擎等。

&emsp;&emsp;也就是说, 没有银弹这句话的正确性, 在软件开发中几乎是真理教条级别的。

### 解决: 保持灵活增量, 用正确的工具做正确的事情

&emsp;&emsp;在这个时代的程序员是非常幸运的, 大量的编程语言和编程范式被总结出来, 我们的工具箱已经变大了许多。在当下, 追求银弹的行为可以说已经落后于时代了。

&emsp;&emsp;首先当下软件系统已经变得非常灵活。如今的程序员有了共享库, 静态反射, 动态运行时meta, 跨语言绑定等利器。当下的软件架构早已不再静态, 不同专门语言/库之间的互操作已经成为常态了。较低的工具交互成本使得我们能够更自由的用合适的工具做正确的事情。在Sakura中会有如下表现/实践:

- 多编程范式的使用: 适合OO的部分, 就使用OO。适合ECS/FP/DP的部分, 我们也会果断进行切换;
- 多编程语言: 在项目中, 我们总为模块选用最合适的语言。
  - 为了性能考量, 所有的游戏引擎都会以C++作为主要语言, Sakura也一样。
  - 而文件批处理和代码生成, 我们用python这种动态解释器, 直接运行代码的语言。
  - 对于脚本绑定, 我们将会导出到lua或者C#这样的语言去(如今 .net core跨平台了);
  

&emsp;&emsp;如今的程序员可以选用这样的处理方式, 其实有如下的原因在:

- 其一是软件工程经过几十年的发展, 理论更成熟, 范式更多;
- 其二是软件的规模进一步变大, 问题更难, 人员规模更大, 使得每个程序员基本只解决单一领域的问题了。比如游戏开发就分物理程序, 图形程序, 游戏性程序, 引擎程序等。他们也乐于接受自己领域的最优方案, 因此不必太担心不同范式带来的接口不一致性;
- 其三是硬件更给力了。就桌面平台讲, 现在的桌面CPU频率已经高到可以忽略程序动态自省所需要的overhead了。dll查个符号表, virtual查虚表多跳转一两次, 根本就不是问题。只要内存IO不出大问题, 基本上效率不会出太大问题。

## 结语
&emsp;&emsp;那么在大致写了两个方面后, 这篇读后感也就暂时落下帷幕了。事实上Sakura还有很多受到启发而重构的部分, 一是篇幅太长, 二是问题较为专门化不太好进行通用描述。如果感兴趣, 可以到Sakura的[文档页](https://saeruhikari.github.io/SakuraEngine/)详细了解。

&emsp;&emsp;《人月神话》一书, 着实是一本好书(虽然本篇读后感讲了很多自己的理解, 书中引用反而少了)。在我看来, 此书是一本厚重有韵味的著作, 即使在数十年后翻开我也一定会有新的收获。最后就用二十周年纪念版的结语来进行收尾:

<h4 align="left"> &emsp;&emsp;软件工程的焦油坑在将来很长一段时间内会继续地使人们举步维艰，无法自拔。软件系统可能是人类创造中最错综复杂的事物，只能期待人们在力所能及的或者刚刚超越力所能及的范围内进行探索和尝试。</h4>
<h4 align="left">
&emsp;&emsp;这个复杂的行业需要：进行持续的发展；学习使用更大的要素
来开发；新工具的最佳使用；经论证的管理方法的最佳应用；良好判断的自由发挥；以及能
够使我们认识到自己不足和容易犯错的——上帝所赐予的谦卑 </h4>


<h5 align="right">---1704101班 170200906-黄政</h4>
<h5 align="right">---Engine Engineer SaeruHikari</h4>

